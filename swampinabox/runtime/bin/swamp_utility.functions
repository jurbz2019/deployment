#!/bin/bash

# This file is subject to the terms and conditions defined in
# 'LICENSE.txt', which is part of this source code distribution.
#
# Copyright 2012-2019 Software Assurance Marketplace

#
# General-purpose utility functions for the SWAMP.
#

############################################################################

#
# Install RPMs using 'yum'.
#
yum_install() {
    echo "Installing: $*"
    yum -y install "$@"
}

#
# Uninstall RPMs using 'yum'.
#
yum_erase() {
    echo "Erasing: $*"
    yum -y erase "$@"
}

#
# Check whether there are RPMs providing the given list of resources.
#
yum_confirm() {
    local not_installed=()
    for pkg in "$@" ; do
        printf 'Checking for %s ... ' "$pkg"
        if ! rpm -q --whatprovides "$pkg" 2>&1 ; then
            not_installed+=("$pkg")
        fi
    done
    if [ ${#not_installed[@]} -gt 0 ]; then
        echo
        echo "Error: No packages provide: ${not_installed[*]}" 1>&2
        return 1
    fi
    return 0
}

#
# Write to standard out the installed version and release of the given RPM.
#
get_rpm_version() {
    local pkg=$1
    if yum_confirm "$pkg" 1>/dev/null 2>&1 ; then
        rpm -q --qf "%{VERSION}-%{RELEASE}" "$pkg"
    else
        echo ""
    fi
}

############################################################################

#
# Write to standard out this host's operating system.
#
get_os_distribution() {
    if [ -r /etc/centos-release ]; then
        echo "CentOS Linux"
        return 0
    fi
    if [ -r /etc/redhat-release ]; then
        echo "Red Hat Linux"
        return 0
    fi
    echo "Unknown"
    return 1
}

#
# Write to standard out this host's operating system's major version.
#
get_os_version() {
    if [ -r /etc/centos-release ]; then
        awk '{ print substr($0, match($0, /[[:digit:]]+/), RLENGTH) ; }' \
            /etc/centos-release
        return 0
    fi
    if [ -r /etc/redhat-release ]; then
        awk '{ print substr($0, match($0, /[[:digit:]]+/), RLENGTH) ; }' \
            /etc/redhat-release
        return 0
    fi
    echo "Unknown"
    return 1
}

############################################################################

#
# Prevent a system service from automatically starting on system startup.
#
disable_service() {
    local svc=$1
    echo "Disabling the $svc system service"
    if command -v systemctl 1>/dev/null 2>&1 ; then
        systemctl disable "$svc"
    else
        chkconfig "$svc" off
    fi
}

#
# Allow a system service to automatically start on system startup.
#
enable_service() {
    local svc=$1
    echo "Enabling the $svc system service"
    if command -v systemctl 1>/dev/null 2>&1 ; then
        systemctl enable "$svc"
    else
        chkconfig "$svc" on
    fi
}

#
# Manage a system service.
#
tell_service() {
    "$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"/../sbin/swamp_manage_service "$@"
}

############################################################################

#
# Create a new group, and add existing user accounts to it.
#
create_group() {
    local new_group=$1

    echo "Creating the $new_group group"
    groupadd -f "$new_group"

    for user_account in "${@:2}" ; do
        if ! groupmems -g "$new_group" -l | grep -q "\\<$user_account\\>"
        then
            echo "Adding $user_account to the $new_group group"
            groupmems -g "$new_group" -a "$user_account"
        else
            echo "Found $user_account in the $new_group group"
        fi
    done
}

#
# Create a new user account.
#
create_user() {
    local new_user=$1

    if [ -z "$(getent passwd "$new_user")" ]; then
        echo "Creating the $new_user user"
        useradd "$new_user"
    else
        echo "Found the $new_user user"
    fi
}

#
# Check whether the given commands are in the current user's $PATH.
#
check_for_commands() {
    for cmd in "$@" ; do
        printf 'Checking for %s ... ' "$cmd"
        if ! command -v "$cmd" 2>&1 ; then
            echo    # write a newline because 'command' printed nothing
            echo
            echo "Error: '$cmd' is not in $USER's \$PATH" 1>&2
            return 1
        fi
    done
    return 0
}

############################################################################

#
# Store the commands for undoing the changes made by 'setup_db_support'.
#
_db_cleanup_cmds=()
_exit_db_setup() { reset_db_support ; exit 1 ; }

#
# Ensure that:
#   - The 'mysql' system service is running
#   - The SWAMP's default options file is available
#
setup_db_support() {
    local SBIN
    SBIN=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)/../sbin

    if [ "$(whoami)" != "root" ]; then
        echo "Error: This utility must be run as 'root'. Perhaps use 'sudo'." 1>&2
        exit 1
    fi
    if [ "$(tell_service mysql status)" = "stopped" ]; then
        _db_cleanup_cmds+=("tell_service mysql stop")
        tell_service mysql start || _exit_db_setup
    fi
    if [ ! -e /etc/.mysql_root ] && [ ! -e /etc/.mysql ]; then
        _db_cleanup_cmds+=("rm -f /etc/.mysql_root")
        "$SBIN"/create_mysql_root /etc/.mysql_root --test || _exit_db_setup
    fi
    if [ ! -e /opt/swamp/sql/sql.cnf ]; then
        _db_cleanup_cmds+=("rm -f /opt/swamp/sql/sql.cnf")
        "$SBIN"/create_mysql_root_cnf /opt/swamp/sql/sql.cnf || _exit_db_setup
    fi
}

#
# Undo the changes made by 'setup_db_support'.
#
reset_db_support() {
    for cleanup_command in "${_db_cleanup_cmds[@]}" ; do
        $cleanup_command
    done

    #
    # Ensure that the terminal's 'echo' property is reset.
    #
    stty echo 1>/dev/null 2>&1 || :

    #
    # Reset the list of cleanup commands.
    #
    _db_cleanup_cmds=()
}

############################################################################

#
# Commands for running 'mysql' and 'mysqldump'.
#
mysql_command="mysql --defaults-file=/opt/swamp/sql/sql.cnf -B -N"
mysqldump_command="mysqldump --defaults-file=/opt/swamp/sql/sql.cnf"

#
# Run the SQL statements in the given files.
#
do_mysql_command() {
    if [ -z "$*" ]; then
        return 0
    fi
    for arg in "$@" ; do
        if [ ! -f "$arg" ] || [ ! -r "$arg" ]; then
            echo "Error: Not a readable file: $arg" 1>&2
            return 1
        fi
    done
    cat "$@" | $mysql_command
}
